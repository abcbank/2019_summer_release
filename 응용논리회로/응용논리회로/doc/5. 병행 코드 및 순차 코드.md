# 응용논리회로
## 5. 병행 및 순차 회로
Outline
1. 조합 회로 대 순차 회로
1. 병행 코드 대 순차 코드
2. 비교 및 분석
3. WHEN문(병행 코드)
4. PROCESS
5. IF문(순차 코드)
6. CASE문(순차 코드)


### 1. 조합회로 대 순차회로
- 조합 : 회로의 출력이 현재의 입력에 의해서만 결정. 이전 상태와 관계 없이 회로를 수행한다.
- 순차 : 회로의 출력이 이전의 입력의 영향을 받는다. 즉, 이전의 상태 요소가 현재 상태 요소에 영향을 미친다.(Feedback)

### 2. 병행코드 대 순차코드
- 병행코드 : 코드의 위치에 관계없이 모두 동시에 실행된다. = 코드의 위치를 바꿔도 결과값은 동일하다.
  - 연산자 : 단, 괄호를 통해 계산 순서를 조정할 수 있다.
  - when(when/else 또는 with/when/select)
  - generate
  - block
- 순차코드 : 코드의 위치에 따라 실행 순서가 다르다. = 코드의 위치가 바뀌면 결과값도 바뀐다.
  - 일반적으로 PROCESS를 의미한다.
  - IF, WAIT, CASE, LOOP문과 감지 리스트 사용
  - 감지 리스트에 있는 신호가 변화할떄마다 매번 수행된다.
- VHDL의 코드는 기본적으로 병행적이다. 단지 PROCESS, FUNCTION, 또는 PROCEDURE 내에 있는 문장들만이 순차적이다.

### 3. 비교 및 분석
- **조합** 회로와 **순차** 회로
  - 조합 회로 : 결과가 이전 status의 영향을 받지 않는 회로
  - 순차 회뢰 : 결과가 이전 status의 영향을 받는 회로

- 조합 **회로**와 병행 **코드**
  - 어디까지나 회로와 코드, 즉 아예 서로 다른 개념임을 유의하자.
  - 코드는 가상의 회로를 구현하기 위해 사용하는 개념이다.
  - 회로는 물리적으로 존재하는 회로 혹은 코드를 돌린 결과를 의미한다.
  - 즉, 코드 상에서 조합 회로는 모든 코드가 동시에 수행되는 병행 코드를 통해서만 구현할 수 있다.

- 순차 **회로**와 순차 **코드**
  - 쓰레드 방식으로 수행되는 순차 코드는 조합 회로에서 사용될 수 없다. 따라서 순차 코드가 사용된 모든 회로는 순차 회로이다.
  - 단, 순차 회로는 병행 코드를 이용해 구성할 수 있다.

- 현재 주목해야하는것은 조합 회로와 순차 회로의 차이가 아닌, **병행 코드와 순차 코드의 차이**임에 유의하자. 

### 4. When문(단순형과 선택형)
- 선언 방법
  1. WHEN/ELSE: 
    ```vhdl
    assignment WHEN condition ELSE
    assignment WHEN condition ELSE
    assignment WHEN OTHERS;
    ```
  2. WITH/SELECT/WHEN:
    ```vhdl
    WITH identifier SELECT
    assignment WHEN value,
    assignment WHEN value,
    assignment WHEN OTHERS;
    ```
  - others 구문의 경우, 일반적으로 사용하는 것이 관례지만 컴파일러에 따라 다른 경우가 많다.
  - 조건으로 활용되는 condition의 경우, 수행 순서에 따라 결과값이 바뀌면 안되기 때문에 중간에 condition 변수를 바꾸는 구문이 존재할 수 없다.

- example : 4x1 MUX
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY mux IS
        PORT (
            a, b, c, d : IN STD_LOGIC;
            sel : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
            y : OUT STD_LOGIC
        );
    END MUX;
    -------------------------------------------------------------
    ARCHITECTURE mux1 OF mux IS
    BEGIN
        y <= a WHEN sel = "00" ELSE
             b WHEN sel = "01" ELSE
             c WHEN sel = "10" ELSE
             d WHEN OTHERS;
    END mux1;\
    -------------------------------------------------------------
    ```
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY mux IS
        PORT (
            a,b,c,d : IN STD_LOGIC;
            sel : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
            y : OUT STD_LOGIC
        );
    END MUX;
    -------------------------------------------------------------
    ARCHITECTURE mux2 OF mux IS
    BEGIN
        WITH sel SELECT
            y <= a WHEN "00",
              <= b WHEN "01",
              <= c WHEN "10",
              <= d WHEN OTHERS;
    END mux2;
    -------------------------------------------------------------
    ```
- example : tri-state
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY tri-state IS
        PORT (
            ena : IN STD_LOGIC;
            input : IN STD_LOGIC_VECTOR (7 DOWNTO 0);
            output : OUT STD_LOGIC_VECTOR (7 DOWNTO 0)
        );
    END tri-state;
    -------------------------------------------------------------
    ARCHITECTURE tri-state OF tri-state IS
    BEGIN
        output <= input WHEN (ena = '0') ELSE
                  (OTHERS <= 'Z');
    END tri-state;
    ```

- example : encoder
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY encoder IS
        PORT (
            x : IN STD_LOGIC_VECTOR (7 DOWNTO 0);
            y : OUT STD_LOGIC_VECTOR (2 DOWNTO 0)
        );
    END ENTITY;
    -------------------------------------------------------------
    ARCHITECTURE encoder OF encoder IS
    BEGIN
        y <= "000" WHEN x = "00000001" ELSE
             "001" WHEN x = "00000010" ELSE
             "010" WHEN x = "00000100" ELSE
             "011" WHEN x = "00001000" ELSE
             "100" WHEN x = "00010000" ELSE
             "101" WHEN x = "00100000" ELSE
             "110" WHEN x = "01000000" ELSE
             "111" WHEN x = "10000000" ELSE
             "ZZZ" WHEN OTHERS;
    END encoder;
    ```

### 5. PROCESS
- 특정 변수가 변화할 때마다 실행되고 있는 프로그램을 의미한다.
- 선언 방법
    ```vhdl
    [label : ] PROCESS (sensitivity list)
        [VARIABLE name type [range] [:= initail_value;]]
    BEGIN
        (sequential code)
    END PROCESS [lable];
    ```
- sensitivity list : 해당 프로세스를 수행하며 조건에 해당되는 데이터들을 적어둔다. 여기에 해당되는 변수들이 변화할 때 해당 프로세스를 실행한다.
- VARIABLE : 상수들을 적어둠. 다만 선택사항이며 본 수업에선 쓸 일 거의 없음.
- sequential code : 수행 코드
- label : 선택사항. 코드의 가독성을 위해 사용하는것을 추천한다. 다만 이름과 비슷한 역할이라 VHDL 예약어는 label로 설정할 수 없다.
- 일반적으로 EVENT 속성을 활용해 신호의 변화를 검출한다.
- example : d flip flap(dff)
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY dff IS
        PORT (
            rst, d, clk : IN STD_LOGIC;
            q : OUT STD_LOGIC
        );
    END dff;
    -------------------------------------------------------------
    ARCHITECTURE dff OF dff IS
    BEGIN
        PROCESS (clk, rst)
        BEGIN
            IF (rst = '1') THEN
                q <= '0';
            ELSIF (clk'EVENT AND clk = '1') THEN
                q <= d;
        END IF;
        END PROCESS;
    END dff;
    ```
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY dff IS
        PORT (
            set, rst, d, clk : IN STD_LOGIC;
            q : OUT STD_LOGIC
        );
    END dff;
    -------------------------------------------------------------
    ARCHITECTURE dff OF dff IS
    BEGIN
        PROCESS (clk, rst)
        BEGIN
            IF (set = '1') THEN
                q <= '1';
            ELSIF (rst = '1') THEN
                q <= '0';
            ELSIF (clk'EVENT AND clk = '1') THEN
                q <= d;
        END IF;
        END PROCESS;
    END dff;
    ```
    - 마찬가지로 clk만 있는 dff도 짤 수 있다.

### 6. IF문(순차 코드)
- 선언 방법
    ```vhdl
    IF conditions THEN assignments;
    ELSIF conditions THEN assignments;
    ELSE assignments;
    END IF:
    ```
    - 의미는 c코드 상의 if와 같다.

- example : counter
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY counter IS
        PORT (
            clk : IN STD_LOGIC;
            digit : OUT STD_LOGIC
        );
    END counter;
    -------------------------------------------------------------
    ARCHITECTURE counter OF counter IS
    BEGIN
        count : PROCESS(clk)
            VARIABLE temp : INTEGER RANGE 0 TO 10;
        BEGIN
            IF(clk'EVENT AND clk = '1') THEN
                temp := temp +1;
                IF (temp = 10) THEN tmep :=0; 
                END IF;
            END IF;
            digit <= temp;
        END PROCESS counter;
    END counter;
    ```
### 7. CASE문(순차 코드)
- 선언 방법
    ```vhdl
    CASE identifier IS
        WHEN value => assignment;
        WHEN value => assignment;
        WHEN OTHERS => assignment;
    ```
- 'WHEN OTEHRS => NULL;'을 통해 아무 동작도 일어나지 않는 경우를 표현 가능.
- example : 비동기 리셋을 가진 DFF
    ```vhdl
    -------------------------------------------------------------
    LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    -------------------------------------------------------------
    ENTITY dff IS
        PORT(
            d, clk, rst : IN BIT;
            q : OUT BIT
        );
    -------------------------------------------------------------
    ARCHITECTURE dff3 OF dff IS
    BEGIN
        PROCESS (clk, rst)
        BIGIN
            CASE rst IS
            WHEN '1' => q <= '0'
            WHEN '0' => 
                IF (clk'EVENT AND clk = '1') THEN
                    q <= d;
                END IF:
            WHEN OTHERS => NULL;
        END CASE;
        END PROCESS;
    END dff3;
    ```
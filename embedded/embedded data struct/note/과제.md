```c
#include<stdio.h>
#include<stdlib.h>
#include<Windows.h>

#define SIZE 15
#define IN_STACK -1
#define BLUE 2
#define RED 3
#define YELLOW 4
#define GREEN 5
#define NORTH 1
#define NORTHEAST 2
#define EAST 4
#define SOUTHEAST 8
#define SOUTH 16
#define SOUTHWEST 32
#define WEST 64
#define NORTHWEST 128
#define tail NULL
#define BYTE unsigned char 

typedef struct _node {
	int x;
	int y;
	int dir;
}node;

int bitmap[SIZE*SIZE] = { 0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,
						0,1,1,1,1,1,1,0,0,0,0,0,1,1,0,
						0,1,0,0,0,0,1,0,0,0,1,1,0,1,0,
						0,1,0,1,1,0,1,0,1,1,1,0,0,1,0,
						0,1,0,0,1,0,1,0,1,0,0,0,0,1,0,
						0,1,1,0,1,0,1,0,1,0,0,1,0,1,0,
						0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,
						0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,
						0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,
						0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,
						0,1,1,1,1,1,0,1,0,0,1,1,0,1,0,
						0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,
						0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,
						0,1,0,0,0,1,0,1,1,1,1,1,1,1,0,
						0,1,1,1,1,1,0,0,0,0,0,0,0,0,0
};
int color = 1;
int stack[SIZE*SIZE];
int top;

node* new_node(int i, int j) {
	node *t = (node*)malloc(sizeof(node));
	t->x = j;
	t->y = i;
	t->dir = NORTH;
	return t;
}

void init_stack(void);
void CCA();
void DFS(int i, int j);
void push(node *pre);
void change_color(node* crd, int color);
node* pop();
int stack_empty();
void print_bitmap() {
	for (int i = 0; i < 15; i++) {
		for (int j = 0; j < 15; j++) {
			printf("%2d", bitmap[SIZE*i + j]);
		}
		printf("\n");
	}
}

int main(void) {
	LARGE_INTEGER freq, start, stop;
	double diff;

	printf("Provided Bitmap ! \n\n");
	print_bitmap();

	QueryPerformanceFrequency(&freq); // computer frequency
	QueryPerformanceCounter(&start); // starting point

	CCA();

	QueryPerformanceCounter(&stop); // stopping point
	diff = (double)(stop.QuadPart - start.QuadPart) / freq.QuadPart;

	printf("\nResult ! \n\n");
	print_bitmap();

	printf("\ntime : %f\n", diff);

	while (1);
}

int bitmap_coord(int i, int j, int dir) {
	switch (dir) {
	case NORTH:
		if (i >= 1) return (i - 1)*SIZE + j;
		break;
	case NORTHEAST:
		if (i >= 1 && j < 14) return (i - 1)*SIZE + j + 1;
		break;
	case EAST:
		if (j < 14) return i * SIZE + j + 1;
		break;
	case SOUTHEAST:
		if (i < 14 && j < 14) return (i + 1)*SIZE + j + 1;
		break;
	case SOUTH:
		if (i < 14) return (i + 1)*SIZE + j;
		break;
	case SOUTHWEST:
		if (i < 14 && i >= 1) return (i + 1)*SIZE + j - 1;
		break;
	case WEST:
		if (j >= 1)return i * SIZE + j - 1;
		break;
	case NORTHWEST:
		if (i >= 1 && j <= 1)return (i - 1)*SIZE + j - 1;
		break;
	default:
		printf("\nERROR\n");
	}

	return -1;
}
void init_stack() {
	top = -1;
}

int stack_empty() {
	return top < 0;
}

void push(node *pre) {
	stack[++top] = pre;
}

node* pop() {
	return stack[top--];
}

void CCA() {
	int i, j;
	for (i = 0; i < SIZE; i++)
		for (j = 0; j < SIZE; j++)
			if (bitmap[i*SIZE + j] == 1)
				DFS(i, j);
}

void change_color(node* cur, int color) {
	bitmap[cur->y*SIZE + cur->x] = color;
}


void DFS(int i, int j) {
	int coord;
	node *push_node, *cur, *tmp;
	node *head = new_node(i, j);

	init_stack();
	push(head);

	color++;

	while (!stack_empty()) {
		cur = pop();
		change_color(cur, color);
		while (cur->dir < 256) {
			coord = bitmap_coord(cur->y, cur->x, cur->dir) > 0 ? bitmap_coord(cur->y, cur->x, cur->dir) : 0;
			if (bitmap[coord] == 1) {
				push_node = (node*)malloc(sizeof(node));
				push_node->dir = NORTH;
				push_node->x = coord % SIZE;
				push_node->y = coord / SIZE;
				push(cur);
				push(push_node);
				break;
			}
			cur->dir = cur->dir << 1;
		}
	}
}
```